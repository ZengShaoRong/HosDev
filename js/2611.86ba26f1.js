"use strict";(self["webpackChunkvue_arcgis_0905"]=self["webpackChunkvue_arcgis_0905"]||[]).push([[2611],{12611:function(n,t,e){e.r(t),e.d(t,{buffer:function(){return C},changeDefaultSpatialReferenceTolerance:function(){return Z},clearDefaultSpatialReferenceTolerance:function(){return $},clip:function(){return d},contains:function(){return m},convexHull:function(){return k},crosses:function(){return h},cut:function(){return g},densify:function(){return F},difference:function(){return L},disjoint:function(){return v},distance:function(){return S},equals:function(){return A},extendedSpatialReferenceInfo:function(){return w},flipHorizontal:function(){return B},flipVertical:function(){return G},generalize:function(){return W},geodesicArea:function(){return U},geodesicBuffer:function(){return H},geodesicDensify:function(){return K},geodesicLength:function(){return X},intersect:function(){return V},intersectLinesToPoints:function(){return Y},intersects:function(){return R},isSimple:function(){return N},nearestCoordinate:function(){return _},nearestVertex:function(){return I},nearestVertices:function(){return P},offset:function(){return z},overlaps:function(){return D},planarArea:function(){return M},planarLength:function(){return Q},relate:function(){return J},rotate:function(){return q},simplify:function(){return b},symmetricDifference:function(){return T},touches:function(){return x},union:function(){return E},within:function(){return O}});e(44114),e(32334);var r=e(8388),i=e(86743),u=e(55910);function c(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function o(n){return n?Array.isArray(n)?n.map(o):n.toJSON?n.toJSON():n:n}function a(n){return Array.isArray(n)?n.map((n=>(0,u.rS)(n))):(0,u.rS)(n)}function f(n,t){let e;return Array.isArray(n)?e=n:(e=[],e.push(n),null!=t&&e.push(t)),e}let s;async function l(){return s||(s=(0,r.ho)("geometryEngineWorker",{strategy:"distributed"})),s}async function p(n,t){return(await l()).invoke("executeGEOperation",{operation:n,parameters:o(t)})}async function y(n,t){const e=await l();return Promise.all(e.broadcast("executeGEOperation",{operation:n,parameters:o(t)}))}function w(n){return p("extendedSpatialReferenceInfo",[n])}async function d(n,t){return a(await p("clip",[c(n),n,t]))}async function g(n,t){return a(await p("cut",[c(n),n,t]))}function m(n,t){return p("contains",[c(n),n,t])}function h(n,t){return p("crosses",[c(n),n,t])}function S(n,t,e){return p("distance",[c(n),n,t,e])}function A(n,t){return p("equals",[c(n),n,t])}function R(n,t){return p("intersects",[c(n),n,t])}function x(n,t){return p("touches",[c(n),n,t])}function O(n,t){return p("within",[c(n),n,t])}function v(n,t){return p("disjoint",[c(n),n,t])}function D(n,t){return p("overlaps",[c(n),n,t])}function J(n,t,e){return p("relate",[c(n),n,t,e])}function N(n){return p("isSimple",[c(n),n])}async function b(n){return a(await p("simplify",[c(n),n]))}async function k(n,t=!1){return a(await p("convexHull",[c(n),n,t]))}async function L(n,t){return a(await p("difference",[c(n),n,t]))}async function T(n,t){return a(await p("symmetricDifference",[c(n),n,t]))}async function V(n,t){return a(await p("intersect",[c(n),n,t]))}async function E(n,t=null){const e=f(n,t);return a(await p("union",[c(e),e]))}async function z(n,t,e,r,i,u){return a(await p("offset",[c(n),n,t,e,r,i,u]))}async function C(n,t,e,r=!1){const i=[c(n),n,t,e,r];return a(await p("buffer",i))}async function H(n,t,e,r,i,u){const o=[c(n),n,t,e,r,i,u];return a(await p("geodesicBuffer",o))}async function _(n,t,e=!0){const r=await p("nearestCoordinate",[c(n),n,t,e]);return{...r,coordinate:i.A.fromJSON(r.coordinate)}}async function I(n,t){const e=await p("nearestVertex",[c(n),n,t]);return{...e,coordinate:i.A.fromJSON(e.coordinate)}}async function P(n,t,e,r){return(await p("nearestVertices",[c(n),n,t,e,r])).map((n=>({...n,coordinate:i.A.fromJSON(n.coordinate)})))}function j(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}async function q(n,t,e){if(null==n)throw new nn;const r=n.spatialReference;if(null==(e=e??j(n)))throw new nn;const i=n.constructor.fromJSON(await p("rotate",[r,n,t,e]));return i.spatialReference=r,i}async function B(n,t){if(null==n)throw new nn;const e=n.spatialReference;if(null==(t=t??j(n)))throw new nn;const r=n.constructor.fromJSON(await p("flipHorizontal",[e,n,t]));return r.spatialReference=e,r}async function G(n,t){if(null==n)throw new nn;const e=n.spatialReference;if(null==(t=t??j(n)))throw new nn;const r=n.constructor.fromJSON(await p("flipVertical",[e,n,t]));return r.spatialReference=e,r}async function W(n,t,e,r){return a(await p("generalize",[c(n),n,t,e,r]))}async function F(n,t,e){return a(await p("densify",[c(n),n,t,e]))}async function K(n,t,e,r=0){return a(await p("geodesicDensify",[c(n),n,t,e,r]))}function M(n,t){return p("planarArea",[c(n),n,t])}function Q(n,t){return p("planarLength",[c(n),n,t])}function U(n,t,e){return p("geodesicArea",[c(n),n,t,e])}function X(n,t,e){return p("geodesicLength",[c(n),n,t,e])}async function Y(n,t){return a(await p("intersectLinesToPoints",[c(n),n,t]))}async function Z(n,t){await y("changeDefaultSpatialReferenceTolerance",[n,t])}async function $(n){await y("clearDefaultSpatialReferenceTolerance",[n])}class nn extends Error{constructor(){super("Illegal Argument Exception")}}}}]);
//# sourceMappingURL=2611.86ba26f1.js.map